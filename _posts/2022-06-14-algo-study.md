---
layout: post
title:  "Why study algorithms?"
date:   2022-10-08 00:00:00
categories: programming
---

In this post, we will look at a task dreaded by many: getting better at solving algorithmic challenges. Some think it&rsquo;s worthless, others feel rage about the current hiring industry is blind to what&rsquo;s really important. But we will try to look at this from another perspective to see if it&rsquo;s worth to devote time to get skills necessary for solving computer science problems.

<!--more-->

# Why study algorithms?

Studying algorithms seems boring for many. Software engineers associate this activity with whiteboard interviews, which may software engineers abhor. Leetcode grind is something that we have to do to get through a suboptimal interview process, guided more by folklore and tradition than by rYete and experimentation. However, let&rsquo;s try to ignore this negative stuff for a moment. Writing programs is our trade. And while frameworks, tools and processes that we built to cope with constant requirement flow and large team sizes are important, writing correct and fast algorithms is too.

## Be a better programmer

Data sizes that we work with grow with each year. Data science and machine learning made big data processing a necessity. And with scale comes the importance of writing fast and reliable programs. Having good knowledge of algorithms and data structures can open up new possibilities. In the end, you will be able  to solve more complex and interesting problems. Practice can help you to become a better problem solver. And, let&rsquo;s be honest, a better programmer. Yes, computer science is its own subset of skills. Being good at algorithmic problems won&rsquo;t help you to develop codebases for large teams or coming up with the best solution designs, or using the latest frameworks. Same as doing pull-ups wonâ€™t help you climb mountains. But pull-ups will give you a solid foundation. And this foundation will help you to achieve the best possible results.


## Be a better problem solver

Honing CS will keep your general problem-solving skills sharp, too. And time after time I found out that applying rational thinking, logic and solid reasoning while discussing problems is extremely important. We do not only write code. WE also discuss and solve  many problems every day. And those problems can be tricky.


## Interviews

Last but not least are interviews. I consider pure algorithmic interviews a flawed practice. In fact, [I wrote a whole chapter](https://www.amazon.com/Managing-Data-Science-strategies-sustainable-ebook/dp/B07ZRX5KBM) to present alternatives to whiteboard interviews that make more sense to me in practice. However, let&rsquo;s look at two facts. First, whiteboard interviews are so common that omitting them from your field of view will limit your options when looking for a job. Second, some fascinating jobs really do require you to apply this knowledge. So, completely ignoring algorithms and data structures is not practical. We already collected  lots of reasons to learn this skill, so consider a wider set of interviews you can go through as a bonus on top.

# Resources to study

Many fear solving algorithmic challenges. It seems that if you can&rsquo;t tackle a medium, hard or even an easy problem, that means that you &ldquo;can&rsquo;t&rdquo; solve those types of problems. This is simply untrue. Solving computer science problems is a skill that can be acquired. Some need to work more to achieve results, some catch up faster, but absolutely anyone can learn to do this. The secret, as with anything, is really simple: practice and dedication. Be ready to solve between 200 and 400 problems before you will feel at home with them. This kind of training helps, because solving algorithm challenges amounts to knowing different patterns and approaches that allow you to beak even the most complex problems into manageable pieces. There are quite a lot of standard techniques in the toolbox, and to master them you need to practice.  If you are unfamiliar with computer science and easy level problems feel like a challenge, start by going through a good introductory material. [Grokking Algorithms](https://www.amazon.com/Grokking-Algorithms-illustrated-programmers-curious/dp/1617292230) can be a good book to familiarize yourself with the most common types of problems. And this [Coursera Specialization](https://www.coursera.org/specializations/algorithms) can be a great addition that will deepen your understanding.  Once you have a good grip of the basics, you can hone the craft by going through curated lists of problems. The ones I find most useful are below:

* Cracking The Coding Interview
* [Grind75 List](https://www.techinterviewhandbook.org/grind75?hours=10&weeks=15)

# Methodologies you can use to study

Ok, so we have gone through motivation on why studying algorithms is important and jotted down which resources to use for study. Now, let&rsquo;s figure out how to study. Getting used to cracking computer science problems can be tricky. We can leverage different strategies to study. If you feel stuck, try to switch the way you are learning.  Some people stress that thinking on a solution for at least 20 to 30 minutes before looking at the solution helps them. Others say that it is better to look at the solutions right away if they do not come to you in 1 to 3 minutes. When looking at a solution, it is important to deeply understand it and implement it without rewriting the solution code line-by-line. You can try both approaches and see what works better in your case.  Another frequent problem that people come up with is recalling a solution to a problem that you have solved a while ago. Repetition is the king when it comes to recall. If you can&rsquo;t solve a problem that you have solved a month ago, do not be upset. This is perfectly fine, since our memory needs many repetitions to really internalize something. There is a way to optimize this process. It is called Spaced Repetition System. The idea is to recall items that you want to remember in growing time intervals.  With each successful recall, the repetition will increase. Otherwise, it will shrink on failures. Language learners and medical students heavily benefit from SRS software, and there is no reason why we can&rsquo;t use it to internalize our core algorithms tool set faster. For example, you can use [Anki](https://apps.ankiweb.net/) to create flashcards with problems that you have previously solved and try to continue working on them in SRS schedule. Or you can use Anki as a primary learning tool and let it schedule which problems to solve in each training session. If you do not want to create your own deck, use this one [ready-to-use algorithms deck](https://github.com/donnemartin/interactive-coding-challenges).

Another important aspect is to learn how to design algorithms from scratch. Building using Lego blocks that you have internalized can be fast and especially useful in an interview environment. But there is a whole another level of understanding things. Books like [The Algorithm Design Manual](https://www.algorist.com/) and [Programming Pearls](https://www.amazon.com/Programming-Pearls-Press-Louis-Bentley/dp/0201103311) will show you a different way of thinking. They demonstrate how to design new algorithms and find approaches to solving new problems. The Algorithm Design Manual also contains lots of stories where it&rsquo;s author applied his problem-solving skills to real-world problems. This is very inspiring and can boost your motivation to learn further.


# Conclusion

I hope that this post showed you why learning to solve algorithmic challenges can be a worthwhile endeavor. We also got a list of study resources, both for starter and advanced levels of understanding. At last, we looked at what methodologies you can apply to optimize your study and enrich your routine. 

In this post, we will look at a task dreaded by many: getting better at solving algorithmic challenges. Some think it&rsquo;s worthless, others are enraged at how current hiring industry is blind to what&rsquo;s really important. But we will try to look at this from another perspective to see if it&rsquo;s really worth to devote time to get skills necessary for solving computer science problems.

